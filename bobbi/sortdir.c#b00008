/*
 * Bobbi January-February 2020
 *
 * TODO: Fix mode
 * TODO: Case insensitive sort option
 * TODO: Tool for 'extending' volume dir to more than 4 blocks
 * TODO: Legacy/extended date format conversion
 * TODO: Trimming unused directory blocks
 * TODO: Make a version that doesn't need GNO - eliminate call to stat()
 */

#pragma debug 9
#pragma lint -1
#pragma stacksize 16384
#pragma memorymodel 0
#pragma optimize -1      /* Disable stack repair code */

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <orca.h>
#include <gsos.h>
#include <prodos.h>

#undef DEBUG            /* Enable additional debug printout */
#define CHECK		/* Perform additional integrity checking */

typedef unsigned char uchar;
typedef unsigned int  uint;
typedef unsigned long ulong;

#define NMLEN 15	/* Length of filename */
#define MAXFILES 1000	/* Max files per directory */

/*
 * ProDOS directory header
 * See ProDOS-8 Tech Ref pp. 152
 */
struct pd_dirhdr {
	uchar	typ_len;
	char	name[NMLEN];
	char	reserved[8];
	uchar	ctime[4];
	uchar	vers;
	uchar	minvers;
	uchar	access;
	uchar	entlen;
	uchar	entperblk;
	uchar	filecnt[2];
	uchar	parptr[2];	/* Bitmap pointer in volume dir */
	uchar	parentry;	/* Total blocks LSB in volume dir */
	uchar	parentlen;	/* Total blocks MSB in volume dir */
};

/*
 * ProDOS file entry
 * See ProDOS-8 Tech Ref pp. 155
 */
struct pd_dirent {
	uchar	typ_len;
	char	name[NMLEN];
	uchar 	type;
	uchar	keyptr[2];
	uchar	blksused[2];
	uchar	eof[3];
	uchar	ctime[4];
	uchar	vers;
	uchar	minvers;
	uchar	access;
	uchar	auxtype[2];
	uchar	mtime[4];
	uchar	hdrptr[2];
};

#define BLKSZ 512	/* 512 byte blocks */
#define PTRSZ 4		/* 4 bytes of pointers at beginning of each blk */
#define FLSZ 8192	/* Bytes required for 64K block free-list */

/* Exit codes */
#define EXIT_SUCCESS    0
#define EXIT_BAD_ARG    1
#define EXIT_ALLOC_ERR  2
#define EXIT_FATAL_ERR  3

/*
 * Linked list of directory blocks read from disk
 * Original directory block is stored in data[]
 * Directory block for sorted directory is stored in sorteddata[]
 */
struct block {
	char data[BLKSZ];         /* Original contents of block */
	char sorteddata[BLKSZ];   /* Content block for sorted dir */
	uint blocknum;            /* Block number on disk */
	struct block *next;
};

/*
 * Entry for array of filenames used by qsort()
 */
struct fileent {
	char  name[NMLEN+1]; /* Name converted to upper/lower case */
	char  datetime[20];  /* Date/time as a yyyy-mm-dd hh:mm string */
	uchar type;          /* ProDOS file type */
	uint  blocks;        /* Size in blocks */
	ulong eof;           /* EOF position in bytes */
	uint  order;         /* Hack to make qsort() stable */
	uchar blockidx;      /* Index of dir block (1,2,3 ...)  */
	uchar entrynum;	     /* Entry within the block */
};

/*
 * Entry for list of directory keyblocks to check
 */
struct dirblk {
	uint          blocknum;
	struct dirblk *next;
};

/*
 * Represents a date and time
 */
struct datetime {
	uint  year;
	uchar month;
	uchar day;
	uchar hour;
	uchar minute;
	uchar ispd25format;
};

/* Globals */
static uint totblks;             /* Total # blocks on volume */
static uchar *freelist;          /* Free-list bitmap */
static uchar *usedlist;          /* Bit map of used blocks */
static uchar flloaded = 0;       /* 1 if free-list has been loaded */
static char currdir[NMLEN+1];    /* Name of directory currently processed */
static struct block *blocks = NULL;
static struct dirblk *dirs = NULL;
static struct fileent filelist[MAXFILES];
static uint numfiles;
static uchar entsz;              /* Bytes per file entry */
static uchar entperblk;          /* Number of entries per block */
static char buf[BLKSZ];          /* General purpose scratch buffer */
static char buf2[BLKSZ];         /* General purpose scratch buffer */
static char buf3[BLKSZ];         /* General purpose scratch buffer */
static uint errcount = 0;        /* Error counter */
static uchar dowholedisk = 0;    /* -D whole-disk option */
static uchar dorecurse = 0;      /* -r recurse option */
static uchar dowrite = 0;        /* -w write option */
static uchar doverbose = 0;      /* -v verbose option */
static uchar dodebug = 0;        /* -V very verbose option */
static uchar do_ctime = 0;       /* -k ctime option */
static char sortopts[5] = "";    /* -s:abc list of sort options */
static char caseopts[2] = "";    /* -c:x case conversion option */

/* Prototypes */
void hline(void);
void err(enum errtype severity, char *fmt, ...);
void flushall(void);
int  readdiskblock(uchar device, uint blocknum, char *buf);
int  writediskblock(uchar device, uint blocknum, char *buf);
void fixcase(char *in, char *out, uchar minvers, uchar vers, uchar len);
void lowercase(char *p, uchar len, uchar *minvers, uchar *vers);
void uppercase(char *p, uchar len, uchar *minvers, uchar *vers);
void initialcase(uchar mode, char *p, uchar len, uchar *minvers, uchar *vers);
void convertdatetime(uchar time[4], struct datetime *dt);
int  readfreelist(uchar device);
int  isfree(uint blk);
int  isused(uint blk);
void markused(uint blk);
void checkblock(uint blk, char *msg);
int  seedlingblocks(uchar device, uint keyblk, uint *blkcnt);
int  saplingblocks(uchar device, uint keyblk, uint *blkcnt);
int  treeblocks(uchar device, uint keyblk, uint *blkcnt);
int  forkblocks(uchar device, uint keyblk, uint *blkcnt);
int  subdirblocks(uchar device, uint keyblk, struct pd_dirent *ent,
                  uint blocknum, uint blkentries, uint *blkcnt);
void enqueuesubdir(uint blocknum, uint subdiridx);
int  readdir(uint device, uint blocknum);
int  cmp_name_asc(const void *a, const void *b);
int  cmp_name_desc(const void *a, const void *b);
int  cmp_datetime_asc(const void *a, const void *b);
int  cmp_datetime_desc(const void *a, const void *b);
int  cmp_type_asc(const void *a, const void *b);
int  cmp_type_desc(const void *a, const void *b);
int  cmp_dir_beg(const void *a, const void *b);
int  cmp_dir_end(const void *a, const void *b);
int  cmp_blocks_asc(const void *a, const void *b);
int  cmp_blocks_desc(const void *a, const void *b);
int  cmp_eof_asc(const void *a, const void *b);
int  cmp_eof_desc(const void *a, const void *b);
int  cmp_noop(const void *a, const void *b);
void sortlist(char s);
void printlist(void);
uint blockidxtoblocknum(uint idx);
void copyent(uint srcblk, uint srcent, uint dstblk, uint dstent, uint device);
void sortblocks(uint device);
int  writedir(uchar device);
void freeblocks(void);
void usage(void);
void processdir(uint device, uint blocknum);
void checkfreeandused(void);

/* Horizontal line */
void hline(void) {
	for (uint i=0; i<80; ++i)
		putchar('-');
}

enum errtype {WARN, NONFATAL, FATAL, FATALALLOC, FATALBADARG, FINISHED};

/*
 * Display error message
 */
void err(enum errtype severity, char *fmt, ...) {
	if (severity == FINISHED) {
		hline();
		if (errcount == 0)
			printf("Done - no errors found.\n");
		else
			printf("Done - %u errors\n", errcount);
		hline();
		exit(EXIT_SUCCESS);
	}
	++errcount;
	fputs("  ", stdout);
	va_list v;
	va_start(v, fmt);
	vprintf(fmt, v);
	putchar('\n');
	va_end(v);
	switch (severity) {
	case FATAL:
		printf("Stopping after %u errors\n", errcount);
		exit(EXIT_FATAL_ERR);
	case FATALALLOC:
		printf("Stopping after %u errors\n", errcount);
		exit(EXIT_ALLOC_ERR);
	case FATALBADARG:
		printf("Stopping after %u errors\n", errcount);
		exit(EXIT_BAD_ARG);
	}
}

/*
 * Disable GSOS block cache and flush any unwritten changes
 */
void flushall(void) {
	ResetCacheGS(0); /* Disable block caching */
	short ff[2];
	ff[0] = 1;
	ff[1] = 0;
	FlushGS(ff);
}

/*
 * Read block from disk using ProDOS call
 * buf must point to buffer with at least 512 bytes
 */
int readdiskblock(uchar device, uint blocknum, char *buf) {
#ifdef DEBUG
	printf("Reading dev %2u block %5u\n", device, blocknum);
#endif
#ifdef CHECK
	if (flloaded)
		if (isfree(blocknum))
			err(NONFATAL, "Block %u is marked free!", blocknum);
#endif
	BlockRec br;
	br.blockDevNum = device;
	br.blockDataBuffer = buf;
	br.blockNum = blocknum;
	READ_BLOCK(&br);
	int rc = toolerror();
	if (rc) {
		err(FATAL, "Block read failed, err=%x", rc);
		return -1;
	}
	return 0;
}

/*
 * Write block from disk using ProDOS call
 * buf must point to buffer with at least 512 bytes
 */
int writediskblock(uchar device, uint blocknum, char *buf) {
#ifdef DEBUG
	printf("Writing dev %2u block %5u\n", device, blocknum);
#endif
	if ((strcmp(currdir, "LIB") == 0) ||
	    (strcmp(currdir, "LIBRARIES") == 0)) {
		printf("Not writing library directory %s\n", currdir);
		return 0;
	}
	flushall();
	DIORecGS dr;
	dr.pCount = 6;
	dr.devNum = device;
	dr.buffer = buf;
	dr.requestCount = BLKSZ;
	dr.startingBlock = blocknum;
	dr.blockSize = BLKSZ;
	DWriteGS(&dr);
	if (dr.transferCount != BLKSZ) {
		err(FATAL, "Block write failed");
		return -1;
	}
	return 0;
}

/*
 * Uses the vers and minvers fields of the directory entry
 * as a bitmap representing which characters are upper and which are
 * lowercase
 */
void fixcase(char *in, char *out, uchar minvers, uchar vers, uchar len) {
	uchar idx = 0;
	if (!(vers & 0x80)) {
		for (idx=0; idx<NMLEN; ++idx)
			out[idx] = in[idx];
		out[len] = '\0';
		return;
	}
	vers <<= 1;
	for (int i=0; i<7; ++i) {
		out[idx++] = ((vers&0x80) ? tolower(in[idx]) : in[idx]);
		vers <<= 1;
	}
	for (int i=0; i<8; ++i) {
		out[idx++] = ((minvers&0x80) ? tolower(in[idx]) : in[idx]);
		minvers <<= 1;
	}
	out[len] = '\0';
}

/*
 * Convert filename pointed to by p into lower case (which is recorded
 * as a bitmap in the vers and minvers fields.
 */
void lowercase(char *p, uchar len, uchar *minvers, uchar *vers) {
	uchar idx = 0;
	*vers = 0x01;
	*minvers = 0x00;
	for (uint i=0; i<7; ++i) {
		*vers <<= 1;
		if ((idx < len) && isalpha(p[idx++]))
			*vers |= 0x01;
	}
	for (uint i=0; i<8; ++i) {
		*minvers <<= 1;
		if ((idx < len) && isalpha(p[idx++]))
			*minvers |= 0x01;
	}
}

/*
 * Convert filename pointed to by p into upper case (which is recorded
 * as a bitmap in the vers and minvers fields.
 */
void uppercase(char *p, uchar len, uchar *minvers, uchar *vers) {
	*vers = 0x00;
	*minvers = 0x00;
}

/*
 * Convert filename pointed to by p into to have first letter capitalized
 * (which is recorded as a bitmap in the vers and minvers fields.
 * If mode = 0 then just uppercase the initial char ("Read.me")
 * otherwise camel-case the name ("Read.Me")
 */
void initialcase(uchar mode, char *p, uchar len, uchar *minvers, uchar *vers) {
	uchar idx = 0;
	uchar capsflag = 1;
	*vers = 0x01;
	*minvers = 0x00;
	for (uint i=0; i<7; ++i) {
		*vers <<= 1;
		if ((idx < len) && isalpha(p[idx++]))
			if (!capsflag)
				*vers |= 0x01;
		if ((mode == 1) && !isalpha(p[idx-1]))
			capsflag = 1;
		else
			capsflag = 0;
	}
	for (uint i=0; i<8; ++i) {
		*minvers <<= 1;
		if ((idx < len) && isalpha(p[idx++]))
			if (!capsflag)
				*minvers |= 0x01;
		if ((mode == 1) && !isalpha(p[idx-1]))
			capsflag = 1;
		else
			capsflag = 0;
	}
}

segment "extra";

/*
 * Read the first block of a directory and deduce the device ID and block
 * number of the first block of the directory.
 */
uchar firstblk(char *dirname, uchar *device, uint *block) {
	int fp;
	uchar rv = 0;

	fp = open(dirname, O_RDONLY);
	if (!fp) {
		err(NONFATAL, "Error opening dir %s", dirname);
		rv = 1;
		goto ret;
	}

	ssize_t len = read(fp, buf, BLKSZ);
	if (len != BLKSZ) {
		err(NONFATAL, "Error reading first block of dir %s", dirname);
		rv = 1;
		goto ret;
	}

	struct stat st;
	if (stat(dirname, &st) == -1)
		err(FATAL, "Can't stat %s", dirname);

	if (!S_ISDIR(st.st_mode))
		err(FATAL, "%s is not a directory", dirname);

	*device = st.st_dev;

	struct pd_dirhdr *hdr = (struct pd_dirhdr*)(buf + PTRSZ);

	/* Detect & handle volume directory */
	if ((hdr->typ_len & 0xf0) == 0xf0) {
		*block = 2;
		goto ret;
	}

#ifdef CHECK
	if ((hdr->typ_len & 0xf0) != 0xe0) {
		err(NONFATAL, "Bad storage type");
		rv = 1;
		goto ret;
	}
#endif

	/* Handle subdirectory */
	uint parentblk    = hdr->parptr[0] + 256U * hdr->parptr[1];
	uint parententry  = hdr->parentry;
	uint parententlen = hdr->parentlen;

	/* Read parent directory block */
	if (readdiskblock(*device, parentblk, buf) == -1)
		err(FATAL, "Can't read parent directory for %s", dirname);

	struct pd_dirent *ent =
	  (struct pd_dirent *)(buf + PTRSZ + (parententry-1) * parententlen);

	*block = ent->keyptr[0] + 256U * ent->keyptr[1];

ret:
	if (fp)
		close(fp);
	return rv;
}

/*
 * Parse mtime or ctime fields and populate the fields of the datetime struct
 * Supports the legacy ProDOS date/time format as used by ProDOS 1.0->2.4.0
 * and also the new format introduced with ProDOS 2.5.
 */
void convertdatetime(uchar time[4], struct datetime *dt) {
	uint d = time[0] + 256U * time[1];
	uint t = time[2] + 256U * time[3];
	if (!(t & 0xe000)) {
		/* ProDOS 1.0 to 2.4.2 date format */
		dt->year   = (d & 0xfe00) >> 9;
		dt->month  = (d & 0x01e0) >> 5;
		dt->day    = d & 0x001f;
		dt->hour   = (t & 0x1f00) >> 8;
		dt->minute = t & 0x003f;
		dt->ispd25format = 0;
		if (dt->year < 40) /* See ProDOS-8 Tech Note 48 */
			dt->year += 2000;
		else
			dt->year += 1900;
	} else {
		/* ProDOS 2.5.0+ */
		dt->year   = t & 0x0fff;
		dt->month  = ((t & 0xf000) >> 12) - 1;
		dt->day    = (d & 0xf800) >> 11;
           	dt->hour   = (d & 0x07c0) >> 6; 
		dt->minute = d & 0x003f;
		dt->ispd25format = 1;
	}
}

/*
 * Read the free list
 */
int readfreelist(uchar device) {
	freelist = (uchar*)malloc(FLSZ);
	if (!freelist)
		err(FATALALLOC, "** Unable to allocate memory **");
	bzero(freelist, FLSZ);
	usedlist = (uchar*)malloc(FLSZ);
	if (!usedlist)
		err(FATALALLOC, "** Unable to allocate memory **");
	bzero(usedlist, FLSZ);
	markused(0); /* Boot block */
	markused(1); /* SOS boot block */
	if (readdiskblock(device, 2, buf) == -1) {
		err(NONFATAL, "Error reading volume dir");
		return -1;
	}
	uint flblk = buf[0x27] + 256U * buf[0x28];
	totblks = buf[0x29] + 256U * buf[0x2a];
	if (doverbose)
		printf("Volume has %u blocks\n", totblks);
	uint flsize = totblks / 4096U;
	if ((flsize % 4096) >0)
		++flsize;
	char *p = (char*)freelist;
	for (uint i=0; i<flsize; ++i) {
		markused(flblk);
		if (readdiskblock(device, flblk++, p) == -1) {
			err(NONFATAL, "Error reading free list");
			return -1;
		}
		p += BLKSZ;
	}
	flloaded = 1;
	return 0;
}

/*
 * Determine if block blk is free or not
 */
int isfree(uint blk) {
	uint idx = blk / 8;
	uint bit = blk % 8;
	return (freelist[idx] << bit) & 0x80 ? 1 : 0;
}

/*
 * Determine if block blk is used or not
 */
int isused(uint blk) {
	uint idx = blk / 8;
	uint bit = blk % 8;
	return (usedlist[idx] << bit) & 0x80 ? 1 : 0;
}

/*
 * Mark a block as used
 */
void markused(uint blk) {
	uint idx = blk / 8;
	uint bit = blk % 8;
	usedlist[idx] |= (0x80 >> bit);
}

/*
 * Perform all the operations to check a block which is used by
 * a directory or file.  Complains if the block is on the free-list
 * and also if we have encountered this block in a previous file or dir.
 */
void checkblock(uint blk, char *msg) {
	if (isfree(blk))
		err(WARN, "%s block %u is marked free!", msg, blk);
	if (isused(blk))
		err(WARN, "%s block %u is already used!", msg, blk);
	markused(blk);
}

/*
 * Count the blocks in a seedling file
 */
int seedlingblocks(uchar device, uint keyblk, uint *blkcnt) {
	checkblock(keyblk, "Data");
	*blkcnt = 1;
	return 0;
}

/*
 * Count the blocks in a sapling file
 */
int saplingblocks(uchar device, uint keyblk, uint *blkcnt) {
	checkblock(keyblk, "Data");
	if (readdiskblock(device, keyblk, buf) == -1) {
		err(NONFATAL, "Error reading blk %u", keyblk);
		return -1;
	}
	*blkcnt = 1;
	for (uint i=0; i<256; ++i) {
		uint p = buf[i] + 256U * buf[i+256];
		if (p) {
			checkblock(p, "Data");
			++(*blkcnt);
		}
	}
	return 0;
}

/*
 * Count the blocks in a tree file
 */
int treeblocks(uchar device, uint keyblk, uint *blkcnt) {
	checkblock(keyblk, "Tree index");
	if (readdiskblock(device, keyblk, buf2) == -1) {
		err(NONFATAL, "Error reading blk %u", keyblk);
		return -1;
	}
	*blkcnt = 1;
	for (uint i=0; i<256; ++i) {
		uint p = buf2[i] + 256U * buf2[i+256];
		if (p) {
			uint b;
			if (saplingblocks(device, p, &b) == 0)
				*blkcnt += b;
			else
				return -1;
		}
	}
	return 0;
}

/*
 * Count the blocks in a GSOS fork file
 * See http://1000bit.it/support/manual/apple/technotes/pdos/tn.pdos.25.html
 */
int forkblocks(uchar device, uint keyblk, uint *blkcnt) {
	checkblock(keyblk, "Fork key");
	if (readdiskblock(device, keyblk, buf3) == -1) {
		err(NONFATAL, "Error reading blk %u", keyblk);
		return -1;
	}
	*blkcnt = 1;
	uint count;

	/* Data fork */
	uchar type = buf3[0x00];
	keyblk = buf3[0x01] + 256U * buf3[0x02];
	uint blks = buf3[0x03] + 256U * buf3[0x04];
	switch (type) {
	case 0x1:
		/* Seedling */
		seedlingblocks(device, keyblk, &count);
		break;
	case 0x2:
		/* Sapling */
		saplingblocks(device, keyblk, &count);
		break;
	case 0x3:
		/* Tree */
		treeblocks(device, keyblk, &count);
		break;
	default:
		err(NONFATAL, "Invalid storage type for data fork");
		count = 0;
		break;
	}
	if (blks != count) {
		if (count != 0) {
			err(NONFATAL,
			    "Data fork size %u is incorrect, should be %u",
			    blks, count);
			// TODO: FIX MODE
		}
	}
	*blkcnt += count;

	/* Data fork */
	type = buf3[0x100];
	keyblk = buf3[0x101] + 256U * buf3[0x102];
	blks = buf3[0x103] + 256U * buf3[0x104];
	switch (type) {
	case 0x1:
		/* Seedling */
		seedlingblocks(device, keyblk, &count);
		break;
	case 0x2:
		/* Sapling */
		saplingblocks(device, keyblk, &count);
		break;
	case 0x3:
		/* Tree */
		treeblocks(device, keyblk, &count);
		break;
	default:
		err(NONFATAL, "Invalid storage type for resource fork");
		count = 0;
		break;
	}
	if (blks != count) {
		if (count != 0) {
			err(NONFATAL,
			    "Res fork size %u is incorrect, should be %u",
			    blks, count);
			// TODO: FIX MODE
		}
	}
	*blkcnt += count;

	return 0;
}

/*
 * Count the blocks in a subdirectory
 */
int  subdirblocks(uchar device, uint keyblk, struct pd_dirent *ent,
                  uint blocknum, uint blkentries, uint *blkcnt) {

	if (!dorecurse)
		checkblock(keyblk, "Directory");
	if (readdiskblock(device, keyblk, buf) == -1) {
		err(NONFATAL, "Error reading keyblock %u", keyblk);
		return -1;
	}
	*blkcnt = 1;
	struct pd_dirhdr *hdr = (struct pd_dirhdr*)(buf + PTRSZ);
	uchar parentry = hdr->parentry;
	uchar parentlen = hdr->parentlen;
	uint parblk = hdr->parptr[0] + 256U * hdr->parptr[1];

	if (parblk != blocknum) {
		err(NONFATAL, "Bad parent block %u, should be %u",
		    parblk, blocknum);
		// TODO: FIX MODE
	}
	if (parentry != blkentries) {
		err(NONFATAL, "Bad parent block entry %u, should be %u",
		    parentry, blkentries);
		// TODO: FIX MODE
	}
	if (parentlen != 0x27)
		err(NONFATAL, "Bad parent entry length");
	char *dirname = buf + 0x05;
	if (strncmp(dirname, ent->name, NMLEN)) {
		err(NONFATAL,"Subdirectory name mismatch");
		// TODO: FIX MODE
	}

	blocknum = buf[0x02] + 256U * buf[0x03];
	while (blocknum) {
		if (!dorecurse)
			checkblock(blocknum, "Directory");
		if (readdiskblock(device, blocknum, buf) == -1) {
			err(NONFATAL, "Error reading dir block %u", blocknum);
			return -1;
		}
		++(*blkcnt);
		blocknum = buf[0x02] + 256U * buf[0x03];
	}
	return 0;
}

/*
 * Record the keyblock of a subdirectory to be processed subsequently
 * blocknum is the block number of the subdirectory keyblock
 * subdiridx is a sequential counter of the subdirs in the current directory
 */
void enqueuesubdir(uint blocknum, uint subdiridx) {
	struct dirblk *p = (struct dirblk*)malloc(sizeof(struct dirblk));
	if (!p)
		err(FATALALLOC, "** Unable to allocate memory **");
	p->blocknum = blocknum;
	static struct dirblk *prev;
	if (subdiridx == 0) {     /* First subdir is inserted at head of list */
		p->next = dirs;
		dirs = p;
	} else {                  /* Subsequent subdirs follow the previous */
		p->next = prev->next;
		prev->next = p;
	}
	prev = p;
}

/*
 * Read a directory, store the raw directory blocks in a linked list
 * and build filelist[] in preparation for sorting. 
 * device is the device number containing the directory
 * blocknum is the block number of the first block of the directory
 */
int readdir(uint device, uint blocknum) {
	uint errsbefore = errcount;
	uint blkcnt = 1;
	uint hdrblknum = blocknum;

	numfiles = 0;

	blocks = (struct block*)malloc(sizeof(struct block));
	if (!blocks)
		err(FATALALLOC, "** Unable to allocate memory **");
	struct block *curblk = blocks;
	curblk->next = NULL;
	curblk->blocknum = blocknum;

	checkblock(blocknum, "Directory");
	if (readdiskblock(device, blocknum, curblk->data) == -1) {
		err(NONFATAL, "Error reading dir block %d", blkcnt);
		return 1;
	}

	struct pd_dirhdr *hdr = (struct pd_dirhdr*)(curblk->data + PTRSZ);

	entsz           = hdr->entlen;
	entperblk       = hdr->entperblk;
	uint filecount  = hdr->filecnt[0] + 256U * hdr->filecnt[1];


	fixcase(hdr->name, currdir,
	        hdr->vers, hdr->minvers, hdr->typ_len & 0x0f);

	hline();
	printf("Directory %s (%u", currdir, filecount);
	printf(" %s)\n", filecount == 1 ? "entry" : "entries");
	hline();

	/* Copy pointers and header to sorteddata[], zero the rest */
	bzero(curblk->sorteddata, BLKSZ);
	memcpy(curblk->sorteddata, curblk->data, PTRSZ + entsz);

#ifdef CHECK
	if (entsz != 0x27) {
		err(NONFATAL, "Error - bad entry size");
		return 1;
	}
	if (entperblk != 0x0d) {
		err(NONFATAL, "Error - bad entries/block");
		return 1;
	}
#endif
	uint idx = entsz + PTRSZ; /* Skip header */
	uchar blkentries = 2;
	uchar entries = 0;
	uint subdirs = 0;

	while (1) {
		struct pd_dirent *ent = (struct pd_dirent*)(curblk->data + idx);
		if (ent->typ_len != 0) {

			if (strlen(caseopts) > 0) {
				switch (caseopts[0]) {
				case 'u':
					uppercase(ent->name,
					          ent->typ_len & 0x0f,
			                          &(ent->vers),
					          &(ent->minvers));
					break;
				case 'l':
					lowercase(ent->name,
					          ent->typ_len & 0x0f,
			                          &(ent->vers),
					          &(ent->minvers));
					break;
				case 'i':
					initialcase(0,
					            ent->name,
					            ent->typ_len & 0x0f,
			                            &(ent->vers),
					            &(ent->minvers));
					break;
				case 'c':
					initialcase(1,
					            ent->name,
					            ent->typ_len & 0x0f,
			                            &(ent->vers),
					            &(ent->minvers));
					break;
				}
			}

			static char namebuf[NMLEN+1];

			fixcase(ent->name, namebuf,
			        ent->vers, ent->minvers, ent->typ_len & 0x0f);
#ifdef CHECK
			switch (ent->typ_len & 0xf0) {
			case 0x10:
				fputs("Seed  ", stdout);
				break;
			case 0x20:
				fputs("Sapl  ", stdout);
				break;
			case 0x30:
				fputs("Tree  ", stdout);
				break;
			case 0x40:
				fputs("Pasc  ", stdout);
				break;
			case 0x50:
				fputs("Fork  ", stdout);
				break;
			case 0xd0:
				fputs("Dir   ", stdout);
				break;
			default:
				fputs("????  ", stdout);
				break;
			}
			puts(namebuf);
#endif
			uint blks = ent->blksused[0] + 256U * ent->blksused[1];
			ulong eof = ent->eof[0] + 256L * ent->eof[1] +
			            65536L * ent->eof[2];
			for (uchar i=0; i<NMLEN+1; ++i)
				filelist[numfiles].name[i] = '\0';
			for (uchar i=0; i<(ent->typ_len & 0x0f); ++i)
				filelist[numfiles].name[i] = namebuf[i];
			filelist[numfiles].type = ent->type;
			filelist[numfiles].blockidx = blkcnt;
			filelist[numfiles].entrynum = blkentries;
			filelist[numfiles].blocks = blks;
			filelist[numfiles].eof = eof;

			struct datetime dt;
			convertdatetime(do_ctime ? ent->ctime : ent->mtime,
			                &dt);
			sprintf(filelist[numfiles].datetime,
			        "%04d-%02d-%02d %02d:%02d %s",
			        dt.year, dt.month, dt.day, dt.hour, dt.minute,
			        (dt.ispd25format ? "*" : " "));

#ifdef CHECK
			uint keyblk = ent->keyptr[0] + 256U * ent->keyptr[1];
			uint hdrblk = ent->hdrptr[0] + 256U * ent->hdrptr[1];
			if (hdrblk != hdrblknum) {
				err(NONFATAL, "Header ptr %u, should be %u",
				    hdrblk, hdrblknum);
				// TODO: FIX MODE
			}
			uint count;
			switch (ent->typ_len & 0xf0) {
			case 0xd0:
				/* Subdirectory */
				enqueuesubdir(keyblk, subdirs++);
				subdirblocks(device, keyblk, ent,
				             blocknum, blkentries, &count);
				break;
			case 0x10:
				/* Seedling */
				seedlingblocks(device, keyblk, &count);
				break;
			case 0x20:
				/* Sapling */
				saplingblocks(device, keyblk, &count);
				break;
			case 0x30:
				/* Tree */
				treeblocks(device, keyblk, &count);
				break;
			case 0x40:
				/* Pascal area */
				puts(" Pascal area!!");
				//
				// TODO: Check name is PASCAL.AREA type 0xef
				//
				count = 0;
				break;
			case 0x50:
				/* File with resource fork */
				forkblocks(device, keyblk, &count);
				break;
			default:
				err(NONFATAL,
				    "%s: unexpected storage type 0x%x",
				     namebuf, ent->typ_len & 0xf0);
				count = 0;
			}
			if (blks != count) {
				if (count != 0) {
					err(NONFATAL,
					    "Size %u is incorrect, "
					    "should be %u", blks, count);
					// TODO: FIX MODE
				}
			}
#endif
			++numfiles;
			if (numfiles == MAXFILES) {
				err(NONFATAL, "** Too many files! **");
				return 1;
			}
			++entries;
		}
		if (blkentries == entperblk) {
			blocknum = curblk->data[0x02] + 256U*curblk->data[0x03];
			if (blocknum == 0) {
				break;
			}
			curblk->next =
			  (struct block*)malloc(sizeof(struct block));
			if (!curblk->next)
				err(FATALALLOC,
				    "** Unable to allocate memory **");
			curblk = curblk->next;
			curblk->next = NULL;
			curblk->blocknum = blocknum;
			++blkcnt;
			checkblock(blocknum, "Directory");
			if ( readdiskblock(device, blocknum,
			                   curblk->data) == -1) {
				err(NONFATAL,"Error reading dir block %d",
				    blkcnt);
				return 1;
			}
			/* Copy ptrs to sorteddata[], zero the rest */
			bzero(curblk->sorteddata, BLKSZ);
			memcpy(curblk->sorteddata, curblk->data, PTRSZ);
			blkentries = 1;
			idx = PTRSZ;
		} else {
			++blkentries;
			idx += entsz;
		}
	}
	if (filecount != entries) {
		err(NONFATAL, "Filecount %u wrong, should be %u",
		    filecount, entries);
		// TODO: FIX MODE
	}
	return errcount - errsbefore;
}

/*
 * Compare - filename sort in ascending order
 */
int cmp_name_asc(const void *a, const void *b) {
	return strncmp(((struct fileent*)a)->name,
	             ((struct fileent*)b)->name, NMLEN);
}

/*
 * Compare - filename sort in descending order
 */
int cmp_name_desc(const void *a, const void *b) {
	return strncmp(((struct fileent*)b)->name,
	               ((struct fileent*)a)->name, NMLEN);
}

/*
 * Compare - date/time sort in ascending order
 */
int cmp_datetime_asc(const void *a, const void *b) {
	return strncmp(((struct fileent*)a)->datetime,
	               ((struct fileent*)b)->datetime, 16);
}

/*
 * Compare - date/time sort in descending order
 */
int cmp_datetime_desc(const void *a, const void *b) {
	return strncmp(((struct fileent*)b)->datetime,
	               ((struct fileent*)a)->datetime, 16);
}

/*
 * Compare - type sort in ascending order
 * Uses the order field to make qsort() stable
 */
int cmp_type_asc(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	int rc = aa->type - bb->type;
	return rc != 0 ? rc : aa->order - bb->order;
}
/*
 * Compare - type sort in descending order
 * Uses the order field to make qsort() stable
 */
int cmp_type_desc(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	int rc = bb->type - aa->type;
	return rc != 0 ? rc : aa->order - bb->order;
}

/*
 * Compare - sort with directories at the beginning
 * Uses the order field to make qsort() stable
 */
int cmp_dir_beg(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	if ((aa->type == 0x0f) && (bb->type != 0x0f))
		return -1;
	if ((bb->type == 0x0f) && (aa->type != 0x0f))
		return 1;
	return aa->order - bb->order;
}

/*
 * Compare - sort with directories at the end
 * Uses the order field to make qsort() stable
 */
int cmp_dir_end(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	if ((aa->type == 0x0f) && (bb->type != 0x0f))
		return 1;
	if ((bb->type == 0x0f) && (aa->type != 0x0f))
		return -1;
	return aa->order - bb->order;
}

/*
 * Compare - sort in increasing order of blocks used
 */
int  cmp_blocks_asc(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	int rc = aa->blocks - bb->blocks;
	return rc != 0 ? rc : aa->order - bb->order;
}

/*
 * Compare - sort in decreasing order of blocks used
 */
int  cmp_blocks_desc(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	int rc = bb->blocks - aa->blocks;
	return rc != 0 ? rc : aa->order - bb->order;
}

/*
 * Compare - sort in increasing order of EOF position
 */
int  cmp_eof_asc(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	long diff = aa->eof - bb->eof;
	if (diff == 0)
		return aa->order - bb->order;
	if (diff > 0)
		return 1;
	else
		return -1;
}

/*
 * Compare - sort in decreasing order of EOF position
 */
int  cmp_eof_desc(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	long diff = bb->eof - aa->eof;
	if (diff == 0)
		return aa->order - bb->order;
	if (diff > 0)
		return 1;
	else
		return -1;
}

/*
 * No-op sort which just keeps items in the same order
 */
int  cmp_noop(const void *a, const void *b) {
	struct fileent *aa = (struct fileent*)a;
	struct fileent *bb = (struct fileent*)b;
	return aa->order - bb->order;
}

/*
 * Sort filelist[]
 * s defines the field to sort on
 */
void sortlist(char s) {
	for(uint i=0; i<numfiles; ++i) {
		filelist[i].order = i;
	}
	switch (s) {
	case 'n':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_name_asc);
		break;
	case 'N':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_name_desc);
		break;
	case 'd':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_datetime_asc);
		break;
	case 'D':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_datetime_desc);
		break;
	case 't':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_type_asc);
		break;
	case 'T':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_type_desc);
		break;
	case 'f':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_dir_beg);
		break;
	case 'F':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_dir_end);
		break;
	case 'b':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_blocks_asc);
		break;
	case 'B':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_blocks_desc);
		break;
	case 'e':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_eof_asc);
		break;
	case 'E':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_eof_desc);
		break;
	case '.':
		qsort(filelist, numfiles, sizeof(struct fileent),
		      cmp_noop);
		break;
	default:
		err(FATALBADARG, "Invalid sort option");
	}
}

/*
 * Print the file info stored in filelist[]
 */
void printlist(void) {
	hline();
	fputs("Dirblk Entry Type : Name            : Blocks      EOF ", stdout);
	if (do_ctime)
		puts("Created");
	else
		puts("Modified");
	for (uint i=0; i<numfiles; ++i) {
		printf("   %03u    %02u   %02x : %s",
		       filelist[i].blockidx,
		       filelist[i].entrynum,
		       filelist[i].type,
		       filelist[i].name);
		for (uint j=0; j<(16-strlen(filelist[i].name)); ++j)
			putchar(' ');
		printf(": %5u  %8lu", filelist[i].blocks, filelist[i].eof);
		printf(" %s\n", filelist[i].datetime);
	}
	hline();
}

/*
 * Convert block index to block number
 * Block index is 1-based (1,2,3 ...)
 */
uint blockidxtoblocknum(uint idx) {
	struct block *p = blocks;
	for (uint i=1; i<idx; ++i)
		if (p)
			p = p->next;
		else {
			puts("** Internal error **");
			exit(3);
		}
	if (!p) {
		puts("** Internal error **");
		exit(3);
	}
	return p->blocknum;
}

/*
 * Copy a file entry from one srcblk, srcent to dstblk, dstent
 * All indices are 1-based.
 */
void copyent(uint srcblk, uint srcent, uint dstblk, uint dstent, uint device) {

	if (dodebug) {
		printf("  from dirblk %03u entry %02u", srcblk, srcent);
		printf("    to dirblk %03u entry %02u", dstblk, dstent);
	}

	uint parentblk = blockidxtoblocknum(dstblk);

	struct block *source = blocks;
	struct block *dest   = blocks;
	while (--srcblk > 0)
		source = source->next;
	while (--dstblk > 0)
		dest = dest->next;
	char *srcptr =  source->data + PTRSZ + (srcent-1) * entsz;
	char *dstptr =  dest->sorteddata + PTRSZ + (dstent-1) * entsz;
	memcpy(dstptr, srcptr, entsz);

	/* For directories, update the parent dir entry number */
	struct pd_dirent *ent = (struct pd_dirent*)dstptr;
	if ((ent->typ_len & 0xf0) == 0xd0) {
		uint block = ent->keyptr[0] + 256U * ent->keyptr[1];
		if (readdiskblock(device, block, buf) == -1) {
			puts("Can't read subdirectory");
			exit(1);
		}
		struct pd_dirhdr *hdr = (struct pd_dirhdr*)(buf + PTRSZ);
		hdr->parptr[0] = parentblk & 0xff;
		hdr->parptr[1] = (parentblk >> 8) & 0xff;
		hdr->parentry = dstent;
		if (dowrite) {
			if (writediskblock(device, block, buf) == -1) {
				puts("Can't write subdirectory");
				exit(1);
			}
		} else {
			if (doverbose)
				puts("Not writing updated subdir without -w");
		}
	}
}

/*
 * Use the sorted list in filelist[] to create a sorted set of directory
 * blocks.  Note that the block and entry numbers are 1-based indices.
 */
void sortblocks(uint device) {
	uchar destblk = 1;
	uchar destentry = 2; /* Skip header on first block */
	for(uint i=0; i<numfiles; ++i) {
		if (dodebug)
			puts(filelist[i].name);
		copyent(filelist[i].blockidx, filelist[i].entrynum,
		        destblk, destentry, device);
		if (destentry++ == entperblk) {
			++destblk;
			destentry = 1;
		}
	}
}

/*
 * Write out the sorted directory
 */
int writedir(uchar device) {
	struct block *i = blocks;
	while (i) {
		if(writediskblock(device, i->blocknum, i->sorteddata) == -1) {
			err(NONFATAL, "Can't write block %u", i->blocknum);
			return 1;
		}
		i = i->next;
	}
	return 0;
}

/*
 * Walk through the linked list freeing memory
 */
void freeblocks(void) {
	struct block *i = blocks, *j;
	while (i) {
		j = i->next;
		free(i);
		i = j;
	}
	blocks = NULL;
}

void usage(void) {
	printf("usage: sortdir [-s xxx] [-n x] [-rDwcvVh] path\n\n");
	printf("  Options: -s xxx  Directory sort options\n");
	printf("           -n x    Filename upper/lower case options\n");
	printf("           -r      Recursive descent\n");
	printf("           -D      Whole-disk mode (implies -r)\n");
	printf("           -w      Enable writing to disk\n");
	printf("           -c      Use create time rather than modify time\n");
	printf("           -v      Verbose output\n");
	printf("           -V      Verbose debugging output\n");
	printf("           -h      This help\n");
	printf("\n");
	printf("Upper/lower case option x:\n");
	printf("  l  convert filenames to lower case           eg: read.me\n");
	printf("  u  convert filenames to upper case           eg: READ.ME\n");
	printf("  i  convert filenames to initial upper case   eg: Read.me\n");
	printf("  c  convert filenames to camel case           eg: Read.Me\n");
	printf("\n");
	printf("Directory sort options xxx, is a list of fields on which\n");
	printf("to sort. The sort options are processed left-to-right.\n");
	printf("  n  sort by filename ascending\n");
	printf("  N  sort by filename descending\n");
	printf("  d  sort by modify (or create [-c]) date ascending\n");
	printf("  D  sort by modify (or create [-c]) date descending\n");
	printf("  t  sort by type ascending\n");
	printf("  T  sort by type descending\n");
	printf("  f  sort folders (directories) to top\n");
	printf("  F  sort folders (directories) to bottom\n");
	printf("  b  sort by blocks used ascending\n");
	printf("  B  sort by blocks used descending\n");
	printf("  e  sort by EOF position ascending\n");
	printf("  E  sort by EOF position descending\n");
	printf("\n");
	printf("e.g.: sortdir -w -s nf .\n");
	printf("Will sort the current directory first by name (ascending),\n");
	printf("then sort directories to the top, and will write the\n");
	printf("sorted directory to disk.\n");
	exit(2);
}

/*
 * Performs all actions for a single directory
 * blocknum is the keyblock of the directory to process
 */
void processdir(uint device, uint blocknum) {
	flushall();
	uchar errs = readdir(device, blocknum);
	if (doverbose) {
		printlist();
	}
	if (errs) {
		printf("Error scanning directory, will not sort\n");
		goto done;
	}
	if (strlen(sortopts) > 0) {
		for (uchar i=0; i<strlen(sortopts); ++i) {
			if (doverbose) {
				printf("Sorting - order '%c' ...\n",
				    sortopts[i]);
			}
			sortlist(sortopts[i]);
		}
		sortblocks(device);
		if (doverbose) {
			puts("After sorting ...");
			printlist();
		}
		if (dowrite)
			errs = writedir(device);
		else if (doverbose)
			puts("Not writing to disk without -w");
	}
done:
	freeblocks();
}

/*
 * Iterate through freelist[] and usedlist[] and see if all is well.
 * If we have visited all files and directories on the volume, every
 * block should either be marked free or marked used.
 */
void checkfreeandused(void) {
	printf("Total blocks on volume %u\n", totblks);
	uint freeblks = 0;
	for (uint i=0; i<totblks; ++i)
		if (isfree(i))
			++freeblks;
	printf("Free blocks on volume %u\n", freeblks);
	for (uint i=0; i<totblks; ++i) {
		uint idx = i / 8;
		if (!(freelist[idx] ^ usedlist[i]))	/* Speed-up */
			continue;
		if (isfree(i)) {
			if (isused(i))
				err(NONFATAL,
				    "Block %u used, marked free", i);
		} else {
			if (!isused(i))
				err(NONFATAL,
				    "Block %u unused, not marked free", i);
		}
	}
}

int main(int argc, char *argv[]) {
	if (argc < 2) {
		usage();
		exit(1);
	}
	int opt;
	while ((opt = getopt(argc, argv, "cDrwvVs:n:h")) != -1) {
		switch (opt) {
		case 'c':
			do_ctime = 1;
			break;
		case 'D':
			dowholedisk = 1;
			dorecurse = 1;
			break;
		case 'r':
			dorecurse = 1;
			break;
		case 'w':
			dowrite = 1;
			break;
		case 'v':
			doverbose = 1;
			break;
		case 'V':
			dodebug = 1;
			break;
		case 's':
			strncpy(sortopts, optarg, 5);
			break;
		case 'n':
			strncpy(caseopts, optarg, 1);
			break;
		case 'h':
		default:
			usage();
		}
	}

	if (optind != argc - 1)
		usage();

	if ((strlen(caseopts) > 0) && (strlen(sortopts) == 0))
		strncpy(sortopts, ".", 1);

	uchar dev;
	uint blk;
	if (firstblk(argv[optind], &dev, &blk) != 0) {
		exit(1);
	}
	readfreelist(dev);
	if (dowholedisk)
		processdir(dev, 2);
	else
		processdir(dev, blk);
	if (dorecurse) {
		while (dirs) {
			struct dirblk *d = dirs;
			blk = dirs->blocknum;
			dirs = d->next;
			free(d);
			processdir(dev, blk);
		}
	}
	if (dowholedisk)
		checkfreeandused();
	free(freelist);
	free(usedlist);
	err(FINISHED, "");
}

